\documentclass[a4paper, 11pt]{report}
%\documentclass{article}  
\usepackage[left=3cm, right=3cm, top=2cm]{geometry}

% language related packages
\usepackage[english]{babel}
\usepackage{amsmath}

% math related packages
\usepackage{amsmath}    % add e.g equation-environment for offset equations
\usepackage{amssymb}    % add some math symbols
%\usepackage{amsthm}     % add theorem environments
\usepackage{ntheorem}	% for nicer theorem environments
\usepackage{esvect}

% \usepackage{blindtext}    % actually not necessary - just for insert blind text
% \usepackage{lipsum}       % does nearly the same like package blindtext

% layout related packages
\usepackage{titlesec}
\usepackage{parskip}		% no itendations
\usepackage{fancyhdr}       % for modifications of e.g. page layout
\usepackage{enumitem}       % for costumizing itemize and enumerate labels
\usepackage{chngcntr}		% changing counters
\usepackage{amsmath}
\usepackage{mathtools}
% graphic related packages
\usepackage[dvipsnames]{xcolor} % using colors
\usepackage{graphicx}           % for inserting pictures
%\usepackage{tikz}
%\usepackage{pgfplots}           % for plots of e.g. functions
%\pgfplotsset{width=10cm,compat=1.9}
%\usepgfplotslibrary{external}
%\tikzexternalize
\usepackage{pgfplots}
\pgfplotsset{compat=1.10} % in my packages used compat=1.15
\usepgfplotslibrary{fillbetween}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{patterns,arrows,calc,decorations.pathmorphing,backgrounds, positioning,fit,petri,decorations.fractals}
\usetikzlibrary{matrix}
\usepackage[makeroom]{cancel}

% referencing objects
\usepackage{cleveref}
\usepackage{bbold}
\usepackage{MnSymbol}

% define theorem enviroments
\theoremstyle{break}
\theorembodyfont{}
\theorempreskip{12pt}      % Abst√§nde
\theorempostskip{6pt}
\newtheorem{definition}{Definition}[chapter]
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{example}[definition]{Example}
\usepackage[normalem]{ulem}

\newtheoremstyle{proofstyle}%
{\item[\hskip\labelsep {\theorem@headerfont ##1}\theorem@separator]}%
{\item[\hskip\labelsep {\theorem@headerfont ##1}\ (##3)\theorem@separator]}

\theoremstyle{proofstyle}
\theoremheaderfont{\normalfont\normalsize\bfseries}
\theorembodyfont{\normalfont\normalsize}
\theoremseparator{\textbf{.}}
\theorempreskip{5pt}
\theorempostskip{5pt}
\theoremsymbol{$\square$}
\newtheorem{proof}{Proof}
\usepackage[
  separate-uncertainty = true,
  multi-part-units = repeat
]{siunitx}
% commands
\renewcommand{\L}{\mathscr{L}}
\newcommand{\R}{\mathbb{R}}

\newcommand\AtPageUpperRight[1]{\AtPageUpperLeft{%
   \makebox[\paperwidth][r]{#1}}}	% i dont know what this thing does...

% change chapter shape
\titleformat{\chapter}[frame]{\bfseries}{\enskip \Large Lecture \;\thechapter \enskip}{8pt}{\vspace{10pt} \LARGE \centering\MakeUppercase}%
\titlespacing{\chapter}{0pt}{0pt}{10pt}

\begin{document}


    
    \textbf{16.12.19} \\
    Case 3: $d=e_x-e_y\leqslant l$ \\
    a) $d=l$ + drawing \\
    b)$d<l-1$ + drawing \\
    c)$d=0$ + drawing \\
    \\
    
    Case 4: $d=e_x-e_y\geqslant 2 \implies $ erasement is not possible! \\
    a) drawing \\
    b) drawing \\
    \\
    
    Case 5: $d=0$ or $d=1 \to $ only then the erasement is possible \\
    a) $d=0$, $x-y$ exact result (by absolute value substraction, $max l=6$ positions) \\
    b) $d=1$ + drawing \\
    c) $d=1$ + drawing \\
    \\
    Note: The addition/substraction can be correctly rounded in a so-called SHORT ACCUMULATOR: + drawing \\
    Floating -point addition (binary) $b=2$: with short accu (L$=l+4$bit)\\
    $z=x\circ y$ with $x=m_x\cdot b^{e_x}\cdot y=m_y\cdot b^{e_y}\cdot z=m_x\cdot b^{e_z}$ \\
    \\
    \begin{enumerate}
        \item  Assumption: $e_x\geqslant e_y$ (otherwise: switch $x$ and $y$) \\
        preliminary exponent $e_z=e_x$, $m_y\to $ akku A
        \item sign $S_x\not = S_y \implies $ build 2er complement of $m_y$ 
        \item Exponent difference $d:=e_x-e_y\geqslant 0$ \\
        slide $m_y$ in akku A to the right (AR-Shift_d(A)) \to ie front zeros if the number is normal or front number ones if number is in 2's complement \\
        \\
        guard digit g=(l+1).bit-position \\
        round digit r=(l+2).bit-position \\
        sticky-bit s=(l+3).bit v(l+4)bit v .. \\
        \\
        \item $A=A+m_x=m_x+m_y\cdot 2^{-d}=m_x$ \\
        If $S_x\not = S_y \land $ leading digit of $m_z=1 \land cout=0$? \\
        \implies $m_z<0 \implies$ 2`s complement of $m_z($in $A)$ \\
        only then possible when $d=e_x-e_y=0$ \\
        \\
        \item \\
        Case 1: Is $S_x=S_y \land cout=1$ (in phase 4)\cdot AR-Shift_1(A) \\
        Case 2: otherwise normalise with LShift_k(A), where $k\in \{0,1,..,l\}$, behind (on (l+1) position) to insert g, behind that all $=0$. \\
        ALWAYS adjust exponent! \\
        \\
        \item In case 5.1) $s:=g \lor r\lor s, r:=(l+1)$ position (per AR-Shift_1)\\
        In case 5.2) $k=0: $ (not Shift), $s:=r\lor s, r:=g$ \\
        $k=1$ (L-Shift_1(A)): here one needs g; g,r,s are defined as in the beginning \\
        $k\geqslant 2$ LShift_k(A), $r=0, s=0 \implies $ the result is exact $\implies$ there is no rounding \\
        \\
        \item Rounding: to conduct with r and s\\
        If $cout=1\implies $ AR-Shift_1(A) \implies $m_z=b^n$ with $n\in Z$ \\
        
        \item To determine the right sign $S_z$ \\
        Example $b=2,l=4,d=l+1=5$ +drawing \\
    \end{enumerate} \bigskip
    
    \begin{itemize}
        \item Exact floating-point operations: \\
        All in/output parameters are FPN in the same FP-format $x,y,q,e,s,t\in R=(R(b,l,e,e)$ \\
        \\
        Here you need to do a table, I am just going to write the content for the table 
        \\
        UP-call , mathematical specification, $R=R(b,l,e,e)$ 
        \begin{enumerate}
            \item exact_add$(x,y,s,t), s,t,\in R: x+- y=s+t$ (mathematical exact) \\
            exact_sub
            \item exact_mul$(x,y,s,t), s,t,\in R: x*y=s+t$ (mathematical exact) 
            \item exact_add$(x,y,q,r), q,r,\in R: x=qy+r$ (mathematical exact) \\
            Assumption: $y\not=0$ and $|r|<|y|\cdot ulp(q)$, \\
            For $x=0 \impliesq=r=0$, so just the case $x\not=0 $ is interesting.\\
            
            \item exact_sqrt$(x,q,r), q,r,\in R: x=q^2+r$ (mathematical exact) \\
            Assumption: $x>0$ and $-2q\cdot ulp(q)+ulp^2(q)<r\leqslant 2\cdot q\cdot ulp(q)$ \\
        \end{enumerate}
    \end{itemize} \bigskip
    
    \textbf{06.01.2020} \\
    Regarding Case 3. Approximate quotient: $q:=0(x/y)$ with arbitrary rounding and exact rest $r:=x-qy$ \\
    \begin{itemize}
        \item trivial case: $q=x/y\implies r=0$ 
        \item otherwise $q\not=x/y \implies r\not=0$ \\
        We choose $q:=(?)(x/y)=x(?)y$ as rounding truncation \\
        \implies $|q|<|x/y|<|q|+ulp(q)$ \\
        \implies $0<|x/y-q|<ulp(q)$ \\
        \implies $0<|x-qy|=|r|<|y|\cdot ulp(q)$ \\
        $qy=M_q\cdot M_y\cdot ulp(q)\cdot ulp(y)$, where $ulp(q)\cdot ulp(y)$ is an elementary unit/granularity, $x=M_x\cdot ulp(x)$ \\
        \\
        Since $|x|>|q|\cdot |y|\implies x=M_x\cdot b^k\cdot ulp(q)\cdot ulp(y)$ with $k\in N$, $r=x-qy=M\cdot ulp(q)\cdot ulp(y)$ with $M=M_x\cdot b^k-M_q\cdot M_y$, $|r|<|y|\cdot ulp(q)=|M_y|\cdot ulp(y)\cdot ulp(q)\implies |M|<|M_y|<b^l$ \implies the rest $r$ can be displayed with maximal $l$ mantissa positions \implies $r\in R$ \\
        \\
        $q_1:=(?)(x/y), r_0:=x$ \\
        The condition $|r_1|<|y|\cdot ulp(q_1)$ makes sense, since for the rest it holds: $|r_1/y|<ulp(q_1)$, i.e. the further quotient shares (corrections for $q_1$) are bounded with $ulp(q_1)$ \implies the division can be continued. \\
        \\
        Algorithm: $r_0:=x$ \\
        $do i=1,n$ !produces n\cdot l quotient digits \\
        $q_i:=(?)(r_{i-1}/y)$ \\
        $r_i:=r_{i-1}-q_i\cdot y$ \\
        end do\\
        \implies approximate the quotient $Q=q_1+q_2+...+q_n$ (not overlapping FLP) and the exact rest $r_n$ which belong there. \\
        \\
        For 4. 
        The condition can, in general, be adhered if $\square$ (to nearest) is used as rounding. \\
        $q:=\square (\sqrt{x}), r:=x-q^2$ \\
        Literatur reprimands: IEEE Conference series\\
        ARITH (proceedings) \\
    \end{itemize} \\
    
    BOOLEAN ALGEBRA \\
    with 2 values: false$=$F$=0$, true$=$T$=1$
    \begin{itemize}
        \item elementary operations\\
        Disjunction (or): $a\lor b=a+b$ \\
        Conjunction (and): $a\land b=a\cdot b=ab$ \\
        Negation (not): $\not a=\sim a=a$\\
        Here is missing the duration (Laufzeit)\\
        Here is also missing the drawing +the table\\
        \\ 
        \item Properties, rules, (?) (and before or!) \\
        -commutative $p\land q=q\land p, p\lor q=q\lor p$ \\
        -associative "and" \\
        -distributive $(p\lor q)\land r=(p\land r)\lor (q\land r)$ \\
        $(p\land q)\lor r=(p\lor r)\land (q\lor r)$ \\
        -idempotent $p\land p=p$, $p\lor p=p$ \\
        -absorbent $p\land (p\lor q)=p$, $p\lor(p\land q)=p$ \\
        - cut out (?) $p\land p=F=0$, $\plor p=T=1$ \\
        -De Morgan: $p\land q=l\lor q$, $p\lor q=p\land q$ \\
        $p\land T=p$, $p\lor F=p$ \\
        $p\land F$, $p\lor T=T$ \\
        $p=p$, $F=T$, $T=F$ \\
    \end{itemize}\bigskip
    
    \textbf{07.01.2020} Adders (2 integers each adding/substracting with $n$ bit)\\
    \begin{itemize}
        \item Half-adder: \\
        Let $a,b$ be each $1$ bit, i.e. $n=1$: +table \\
        \item full adder: builds $\sum$ of $3$ bits in: $a,b,cin;$ out: $cout, S$ \\
        $c=an+ac+bc$ \\
        $s=abc+abc+abc+abc=a\circ b\circ c$ \\
        $c=(ab)+(a+b)\cdot c$\\
        $s=a\circ b\circ c$ +drawing 
        
        \item simple adders for $n-$digit numbers $a=[a_{n-1}a_{n-2}\cdot \cdot \cdot a_0]_2$ and $b=[b_{n-1}b_{n-2}\cdot \cdot \cdot b_0]_2$
        \begin{enumerate}
            \item serial adder \\
            -needs $n$ full-adder-time-units (fatu`s) $\leqslant 4\cdot n$ + drawing
            \item (John) von Neumann-adder: \\
            -historically 1 parallel adder \\
            -latest after $n$ fatus all transfers are processed, ie $B=0$ \\
            - early abort when all bits in $B$ are zero
            
            \item Ripple-Carry-Adder \\
            -T(n) fatus$=3\cdot n+1$tu(?) \\
            Here there are a lot of things missing cause I dont know how to write them?\\
            \\
            \begin{itemize}
                \item Overflow \iff $c_n\not=c_{n-1}$ + table
                
                \item Bit-vector of a number \\
                $B(X)=[x_{n-1}x_{n-2}\cdot \cdot \cdot x_1x_0]_2$ \\
                Value $|B(X)|=\sum_{i=0}^{n-1} x_i\cdot 2^i=$ unsigned value of $x$\\
                1`s complement: $|B(X)|+|B(-X)|=2^n-1$ \\
                2`s complement: $|B(X)|+|B(-X)|=2^n$ \\
                Value in 2`s complement of the number $a$ \\
                $a=-a_{n-1}\cdot 2^{n-1}+\sum_{i=0}^{n-2}a_i\cdot 2^i$, where the minus in front of $a_{n-1}$ is a real minus. \\
            \end{itemize}
            In bit-position $i, i\in\{0,1,..,n-1\}$ it holds: $c_{i+1}=g_i+p_i\cdot c_i$, with $g_i:=a_i\cdot b_i$, $p_i=a_i\circ b_i$ or $a_i+b_i$ \\
            Recursive disintegration: \\
            $c_{i+1}=g_i+p_i\cdot g_{i-1}+p_i\cdot p_{i-1}\cdot g_{i-2}+ ...+p_ip_{i-1} \cdot \cdot \cdot p_1p_0$ \\ 
            Something missing \\
            \\
            \\
            Idea: Binary tree structure: 2`s/4`s/8`s/16`s -groups of bits $G_{0,1}=g_1+p_i\cdot g_0, P_{0,1}=p_1p_0$ \\
            2 groups $[k .... j+1][j ... i]$ \\
            $c_{k+1}=G_{i,t}+p_{i,t}\cdot c_i$, with $G_{i,t}=G_{j+1,k}+P_{j+1,k}\cdot G_{i,j}$ and $P_{i,k}=P_{j+1,k}\cdot P_{i,j}$ \\

        \end{enumerate}
    \end{itemize} \bigskip
    
    \textbf{13.01.2019} \\
    \to CLA $(A.14)(A.15)$ carry-look-ahead \\
    $a_i=b_i=0 \implies c_{i+1}=0$ \\
    $g_i=a_i\cdot b_i \implies c_{i+1}=1$ \\
    $p_i=a_i\circ b_i \implies c_{i+1}=c_i$ \\ 
    $c_{i+1}=g_i+p_i\cdot c_i$ \\
    Here comes another drawing \\
    Literature: David Goldberg: Computer arithmetic\\
    What every computer scientist should know about FP-arithmetic \\
    
    Duration: 1tu=time for 1 $\log$ fence ($\land, \lor$) \\
    $0$ tu`s for NOT\\
    $1$ tu`s for AND(\cdot), OR(+), NAND, NOR\\
    $2$ tu`s for XOR,HA(half-adder)\\
    $1$ fatu=4 tu`s for FA (full adder), but only 3 tu`s for carry-out\\ 
    \\
    \impliesq carry-(?)-adder ( for $n$ bit)\\
    $(3+n+1)$ tu, $1$ for the last sum \\
    $[=193$ tu for $n=64$ bit$]$. +drawing \\
    \\
    (Pseudo)Propagate-bit for a group of $k$ bit:\\
    -$k$ or-gatter (for $p_i=a_i+b_i$) \\
    -binary tree of AND-gatters for $P_{0,k-1}$ \\
    -height of the tree is $h=[\log_2 k]$ \\
    - $(k-1)$ gatter +table\\
    \\
    Generate-bit for $k-$bit group \\
    -can be read as $cout$ through ripple-carry-process with $cin=0$, i.e. with $cin=0$, it holds: group = cout \\
    \to carry-skip-adder (A.19) \\
    irregular design: $k$ groups with different lengths + drawing \\
    \\ There are another two drawings here (a table) \\
    \\
    (*) Optimum: CLA with ripple-carry for every 4 group\\
    \begin{itemize}
        \item Shifting \\
        -L-Shift_1(a) $a_{n-1}\cdot \cdot \cdot a_0\to a_{n-2} \cdot \cdot \cdot a_1 a_0$ \\
        - R-Shift_k(a)  $a_{n-1}\cdot \cdot \cdot a_0\to 00 \cdot \cdot \cdot 0 a_{n-1} \cdot \cdot \cdot a_k$ \\ (Here the bracket is missing) \\
        - arithmetic R-Shift \\
        AR-Shift_1(a) \to $a_{n-1}a_{n-1}a_{n-2}\cdot \cdot \cdot a_{1} \\
        $\sum_{i=1}^{n-1} a_i\cdot 2^{i-1}-a_{n-1}\cdot 2^{n-1}=\sum_{i=1}^{n-2}a_i\cdot 2^{i-1}-a_{n-1}\cdot (2^{n-1}-2^{n-2})=\sum_{i=1}^{n-2}a_i\cdot 2^{i-1}-a_{n-1}\cdot 2^{n-2}=$ 2`s complement of $\frac{a}{2}$ (floor rounding) \\
        \item Multiplication of $2n-$bit numbers \\
        $a*b\to r$ (?) repeated summation of partial products $a_i\cdot b, r=\sum_{i=0}^{n-1}a_i\cdot 2^i\cdot b_i$, $a_{n-1}...a_1a_0$ +2 drawing  \\
        \\
        
        $n-$steps: \\
        \begin{enumerate}
            \item $P=p+a_0\cdot B$; AR-Shift_1(R)
            \item $P=P+a_1B$; AR-Shift_1(R) \\
            ...
            \item $P=P+a_{n-1}\cdot B$; AR-Shift_1(R)
        \end{enumerate} 
        After $n$ steps $R$ contains the whole double-length product P-approximation product, A-exact associated error\\
        T(n)=(?)\\
        
        Improvement: \\
        -A contains groups ov $k$ null \to immediately AR-Shift_k(R) \\
        -A contains group of $k$ ones ($a=..01...10..$), $\sum_{i=j}^l 2^i=2^{l+1}-2^j=2^{j+k}-2^j$ \to (?) k additions through a (+) a (-)\\
        
        Booth- Shifting \\
        $0\to 1 $ substraction \\
        $0101\to 1111$ the lines are missing here \\
        \to not always better \\
        \to but enables sign afficted multiplication 
        \item General 2`s complement multiplication ($a,b$ sign-afficted) \\
        -(?) AR-Shift\\
        -stores the last shifted bit of $a$ (position $a_{-1}$) extra bit at the end \\ 
        - 2`s complement adder work (which must add or subtract $b$) (eventual b(store extra 1`s complement) \\ 
        - a eventual occurring carry-out is discarded \\
        
        Test case: the biggest absolute value $|M|$ for $M=-2^{n-1} $(in 2`s complement) \impliesq $M*M=(-2^{n-1})^2=2^{2(n-1)}$ is the only product, which needs $2n$ bits in 2`s complement \\
        \to $010...0 $ here the bracket is missing \\
        \item An example $n=4, a\cdot b, a=(-6), b=(-5), a=1010, b=1011, -b=0101$ + table  
        
        \item Booth recording is, as the addition: in $i-$th step: $B\cdot (a_{i-1}-a_i)\cdot[2^i] \implies $ sensible only for $k\leqslant 3$, i.e. is more time-consuming then the normalisating algorithm for big $k$. \\
        $\sum_{i=0}^{n-1} B\cdot (a_{i-1}-a_i)\cdot 2^i=B$(2`s complement of a)=$B\cdot A$ \\
        In the first step set $a_{-1}=0$ \\
        in $i-$th step: \\
        $I a_i=0, a_{i-1}=0$ only shift \\
        $II a_i=0, a_{i-1}=1$ $P=P+B$ \\
        $III a_i=1, a_{i-1}=0$ $P=P-B$ \\
        $IV a_i=1, a_{i-1}=1$, only shift \\ 
        
        \item Pipelining: \\
        5-layered : +drawing \\
        \begin{itemize}
            \item one cycle per stage \\ 
            Sequential execution $n\cdot 5$ cycles \\
            Overlapping execution $n+4$ cycles \\
            without pipelining: cycles =(?) \\
            with pipelining: cycles =(?) \\
            \to speedup=pipeline stages 
            
            \item Booth recoding uses sign-bit $D:=\{-1,0,1\}$ \\
            So that one reduces the number of iterations, one uses another basis (radix) (eg. $2^2=4, 2^3=8$) \\
            
            Symmetric minimal number-sets $S=\{-2^{k-1}, -2^{k-1}+1, .., 0, .., 2^{k-1}\}$ for basis (radix) $2^k$, eg. $k-$bit groups \\ 
            \to reduces the number of iterations on $\frac{n}{k}$ ($n-$bit numbers) \\
            An example $k=2\to \frac{n}{2}$ iterations $S=\{-2,-1,0,1,2\}$, basis $4$ booth recording +table \\
            
            \item To summarize $k n-$bit numbers (+) +drawing \\
            - use $n$ FA \\
            -add $2$ (or $3$) $n-$digit numbers\\
            $D_1=[d_{n-1}d_{n-2}...d_{1}d_{0}]_2$ \\
            $D_2=[d_{n-1}d_{n-2}...d_{1}d_{0}]_2$ in the first FA-cycle (1 fatu)\\ 
            - an additional $D_i=[d_{n-1}d_{n-2}...d_{1}d_{0}]_2$ in every FA-cycle until the last $D_k$ (ready after $(k-1)$ fatu) \\
            - finish old carry propagations needs additional $(n-1)$ fatu \\
            $T(n,k)=n+k-2$ (instad of $O(k\cdot n)$ fatu if carries are resolved every time) 
            
            \item Carry-safe-adder (CSA) +drawing 
        \end{itemize} 
        
        
        \end{itemize}
    
    






































\end{document}